import { g as Kt, s as Jt, w as Qt } from "../core-DnsuMG85.js";
import { b as sn, e as un, j as fn, j as cn, p as vn, k as ln } from "../core-DnsuMG85.js";
var hr = (() => {
  var G;
  var W = typeof document < "u" ? (G = document.currentScript) == null ? void 0 : G.src : void 0;
  return function(te = {}) {
    var mr, u = te, yr, K, ne = new Promise((r, e) => {
      yr = r, K = e;
    }), ae = typeof window == "object", ie = typeof Bun < "u", or = typeof importScripts == "function";
    typeof process == "object" && typeof process.versions == "object" && process.versions.node;
    var br = Object.assign({}, u), A = "";
    function oe(r) {
      return u.locateFile ? u.locateFile(r, A) : A + r;
    }
    var wr, sr;
    (ae || or || ie) && (or ? A = self.location.href : typeof document < "u" && document.currentScript && (A = document.currentScript.src), W && (A = W), A.startsWith("blob:") ? A = "" : A = A.substr(0, A.replace(/[?#].*/, "").lastIndexOf("/") + 1), or && (sr = (r) => {
      var e = new XMLHttpRequest();
      return e.open("GET", r, !1), e.responseType = "arraybuffer", e.send(null), new Uint8Array(e.response);
    }), wr = (r) => fetch(r, {
      credentials: "same-origin"
    }).then((e) => e.ok ? e.arrayBuffer() : Promise.reject(new Error(e.status + " : " + e.url)))), u.print || console.log.bind(console);
    var H = u.printErr || console.error.bind(console);
    Object.assign(u, br), br = null, u.arguments && u.arguments, u.thisProgram && u.thisProgram, u.quit && u.quit;
    var B;
    u.wasmBinary && (B = u.wasmBinary);
    var J, Tr = !1, k, g, x, N, D, d, $r, Ar;
    function Er() {
      var r = J.buffer;
      u.HEAP8 = k = new Int8Array(r), u.HEAP16 = x = new Int16Array(r), u.HEAPU8 = g = new Uint8Array(r), u.HEAPU16 = N = new Uint16Array(r), u.HEAP32 = D = new Int32Array(r), u.HEAPU32 = d = new Uint32Array(r), u.HEAPF32 = $r = new Float32Array(r), u.HEAPF64 = Ar = new Float64Array(r);
    }
    var Cr = [], Rr = [], Fr = [];
    function se() {
      if (u.preRun)
        for (typeof u.preRun == "function" && (u.preRun = [u.preRun]); u.preRun.length; )
          ce(u.preRun.shift());
      ur(Cr);
    }
    function ue() {
      ur(Rr);
    }
    function fe() {
      if (u.postRun)
        for (typeof u.postRun == "function" && (u.postRun = [u.postRun]); u.postRun.length; )
          le(u.postRun.shift());
      ur(Fr);
    }
    function ce(r) {
      Cr.unshift(r);
    }
    function ve(r) {
      Rr.unshift(r);
    }
    function le(r) {
      Fr.unshift(r);
    }
    var S = 0, X = null;
    function de(r) {
      var e;
      S++, (e = u.monitorRunDependencies) === null || e === void 0 || e.call(u, S);
    }
    function _e(r) {
      var e;
      if (S--, (e = u.monitorRunDependencies) === null || e === void 0 || e.call(u, S), S == 0 && X) {
        var t = X;
        X = null, t();
      }
    }
    function Pr(r) {
      var e;
      (e = u.onAbort) === null || e === void 0 || e.call(u, r), r = "Aborted(" + r + ")", H(r), Tr = !0, r += ". Build with -sASSERTIONS for more info.";
      var t = new WebAssembly.RuntimeError(r);
      throw K(t), t;
    }
    var pe = "data:application/octet-stream;base64,", Wr = (r) => r.startsWith(pe);
    function ge() {
      var r = "zxing_writer.wasm";
      return Wr(r) ? r : oe(r);
    }
    var Q;
    function kr(r) {
      if (r == Q && B)
        return new Uint8Array(B);
      if (sr)
        return sr(r);
      throw "both async and sync fetching of the wasm failed";
    }
    function he(r) {
      return B ? Promise.resolve().then(() => kr(r)) : wr(r).then((e) => new Uint8Array(e), () => kr(r));
    }
    function Ur(r, e, t) {
      return he(r).then((n) => WebAssembly.instantiate(n, e)).then(t, (n) => {
        H(`failed to asynchronously prepare wasm: ${n}`), Pr(n);
      });
    }
    function me(r, e, t, n) {
      return !r && typeof WebAssembly.instantiateStreaming == "function" && !Wr(e) && typeof fetch == "function" ? fetch(e, {
        credentials: "same-origin"
      }).then((a) => {
        var i = WebAssembly.instantiateStreaming(a, t);
        return i.then(n, function(s) {
          return H(`wasm streaming compile failed: ${s}`), H("falling back to ArrayBuffer instantiation"), Ur(e, t, n);
        });
      }) : Ur(e, t, n);
    }
    function ye() {
      return {
        a: It
      };
    }
    function be() {
      var r = ye();
      function e(n, a) {
        return p = n.exports, J = p.R, Er(), Br = p.U, ve(p.S), _e(), p;
      }
      de();
      function t(n) {
        e(n.instance);
      }
      if (u.instantiateWasm)
        try {
          return u.instantiateWasm(r, e);
        } catch (n) {
          H(`Module.instantiateWasm callback failed with error: ${n}`), K(n);
        }
      return Q || (Q = ge()), me(B, Q, r, t).catch(K), {};
    }
    var ur = (r) => {
      for (; r.length > 0; )
        r.shift()(u);
    };
    u.noExitRuntime;
    var T = (r) => Kr(r), $ = () => Jr(), Sr = [], we = (r) => {
      var e = new fr(r);
      return e.get_caught() || e.set_caught(!0), e.set_rethrown(!1), Sr.push(e), Yr(e.excPtr), e.get_exception_ptr();
    }, j = 0, Te = () => {
      w(0, 0);
      var r = Sr.pop();
      Qr(r.excPtr), j = 0;
    };
    class fr {
      constructor(e) {
        this.excPtr = e, this.ptr = e - 24;
      }
      set_type(e) {
        d[this.ptr + 4 >> 2] = e;
      }
      get_type() {
        return d[this.ptr + 4 >> 2];
      }
      set_destructor(e) {
        d[this.ptr + 8 >> 2] = e;
      }
      get_destructor() {
        return d[this.ptr + 8 >> 2];
      }
      set_caught(e) {
        e = e ? 1 : 0, k[this.ptr + 12] = e;
      }
      get_caught() {
        return k[this.ptr + 12] != 0;
      }
      set_rethrown(e) {
        e = e ? 1 : 0, k[this.ptr + 13] = e;
      }
      get_rethrown() {
        return k[this.ptr + 13] != 0;
      }
      init(e, t) {
        this.set_adjusted_ptr(0), this.set_type(e), this.set_destructor(t);
      }
      set_adjusted_ptr(e) {
        d[this.ptr + 16 >> 2] = e;
      }
      get_adjusted_ptr() {
        return d[this.ptr + 16 >> 2];
      }
      get_exception_ptr() {
        var e = re(this.get_type());
        if (e)
          return d[this.excPtr >> 2];
        var t = this.get_adjusted_ptr();
        return t !== 0 ? t : this.excPtr;
      }
    }
    var $e = (r) => {
      throw j || (j = r), j;
    }, Y = (r) => Gr(r), cr = (r) => {
      var e = j;
      if (!e)
        return Y(0), 0;
      var t = new fr(e);
      t.set_adjusted_ptr(e);
      var n = t.get_type();
      if (!n)
        return Y(0), e;
      for (var a of r) {
        if (a === 0 || a === n)
          break;
        var i = t.ptr + 16;
        if (zr(a, n, i))
          return Y(a), e;
      }
      return Y(n), e;
    }, Ae = () => cr([]), Ee = (r) => cr([r]), Ce = (r, e) => cr([r, e]), Re = (r, e, t) => {
      var n = new fr(r);
      throw n.init(e, t), j = r, j;
    }, Fe = () => {
      Pr("");
    }, z = {}, vr = (r) => {
      for (; r.length; ) {
        var e = r.pop(), t = r.pop();
        t(e);
      }
    };
    function rr(r) {
      return this.fromWireType(d[r >> 2]);
    }
    var O = {}, M = {}, er = {}, jr, Mr = (r) => {
      throw new jr(r);
    }, Ir = (r, e, t) => {
      r.forEach(function(o) {
        er[o] = e;
      });
      function n(o) {
        var f = t(o);
        f.length !== r.length && Mr("Mismatched type converter count");
        for (var c = 0; c < r.length; ++c)
          E(r[c], f[c]);
      }
      var a = new Array(e.length), i = [], s = 0;
      e.forEach((o, f) => {
        M.hasOwnProperty(o) ? a[f] = M[o] : (i.push(o), O.hasOwnProperty(o) || (O[o] = []), O[o].push(() => {
          a[f] = M[o], ++s, s === i.length && n(a);
        }));
      }), i.length === 0 && n(a);
    }, Pe = (r) => {
      var e = z[r];
      delete z[r];
      var t = e.rawConstructor, n = e.rawDestructor, a = e.fields, i = a.map((s) => s.getterReturnType).concat(a.map((s) => s.setterArgumentType));
      Ir([r], i, (s) => {
        var o = {};
        return a.forEach((f, c) => {
          var v = f.fieldName, l = s[c], _ = f.getter, m = f.getterContext, U = s[c + a.length], Z = f.setter, C = f.setterContext;
          o[v] = {
            read: (q) => l.fromWireType(_(m, q)),
            write: (q, gr) => {
              var ir = [];
              Z(C, q, U.toWireType(ir, gr)), vr(ir);
            }
          };
        }), [{
          name: e.name,
          fromWireType: (f) => {
            var c = {};
            for (var v in o)
              c[v] = o[v].read(f);
            return n(f), c;
          },
          toWireType: (f, c) => {
            for (var v in o)
              if (!(v in c))
                throw new TypeError(`Missing field: "${v}"`);
            var l = t();
            for (v in o)
              o[v].write(l, c[v]);
            return f !== null && f.push(n, l), l;
          },
          argPackAdvance: R,
          readValueFromPointer: rr,
          destructorFunction: n
        }];
      });
    }, We = (r, e, t, n, a) => {
    }, ke = () => {
      for (var r = new Array(256), e = 0; e < 256; ++e)
        r[e] = String.fromCharCode(e);
      xr = r;
    }, xr, h = (r) => {
      for (var e = "", t = r; g[t]; )
        e += xr[g[t++]];
      return e;
    }, Dr, y = (r) => {
      throw new Dr(r);
    };
    function Ue(r, e) {
      let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var n = e.name;
      if (r || y(`type "${n}" must have a positive integer typeid pointer`), M.hasOwnProperty(r)) {
        if (t.ignoreDuplicateRegistrations)
          return;
        y(`Cannot register type '${n}' twice`);
      }
      if (M[r] = e, delete er[r], O.hasOwnProperty(r)) {
        var a = O[r];
        delete O[r], a.forEach((i) => i());
      }
    }
    function E(r, e) {
      let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      if (!("argPackAdvance" in e))
        throw new TypeError("registerType registeredInstance requires argPackAdvance");
      return Ue(r, e, t);
    }
    var R = 8, Se = (r, e, t, n) => {
      e = h(e), E(r, {
        name: e,
        fromWireType: function(a) {
          return !!a;
        },
        toWireType: function(a, i) {
          return i ? t : n;
        },
        argPackAdvance: R,
        readValueFromPointer: function(a) {
          return this.fromWireType(g[a]);
        },
        destructorFunction: null
      });
    }, lr = [], F = [], dr = (r) => {
      r > 9 && --F[r + 1] === 0 && (F[r] = void 0, lr.push(r));
    }, je = () => F.length / 2 - 5 - lr.length, Me = () => {
      F.push(0, 1, void 0, 1, null, 1, !0, 1, !1, 1), u.count_emval_handles = je;
    }, I = {
      toValue: (r) => (r || y("Cannot use deleted val. handle = " + r), F[r]),
      toHandle: (r) => {
        switch (r) {
          case void 0:
            return 2;
          case null:
            return 4;
          case !0:
            return 6;
          case !1:
            return 8;
          default: {
            const e = lr.pop() || F.length;
            return F[e] = r, F[e + 1] = 1, e;
          }
        }
      }
    }, Ie = {
      name: "emscripten::val",
      fromWireType: (r) => {
        var e = I.toValue(r);
        return dr(r), e;
      },
      toWireType: (r, e) => I.toHandle(e),
      argPackAdvance: R,
      readValueFromPointer: rr,
      destructorFunction: null
    }, xe = (r) => E(r, Ie), De = (r, e, t) => {
      if (r[e].overloadTable === void 0) {
        var n = r[e];
        r[e] = function() {
          for (var a = arguments.length, i = new Array(a), s = 0; s < a; s++)
            i[s] = arguments[s];
          return r[e].overloadTable.hasOwnProperty(i.length) || y(`Function '${t}' called with an invalid number of arguments (${i.length}) - expects one of (${r[e].overloadTable})!`), r[e].overloadTable[i.length].apply(this, i);
        }, r[e].overloadTable = [], r[e].overloadTable[n.argCount] = n;
      }
    }, Or = (r, e, t) => {
      u.hasOwnProperty(r) ? ((t === void 0 || u[r].overloadTable !== void 0 && u[r].overloadTable[t] !== void 0) && y(`Cannot register public name '${r}' twice`), De(u, r, r), u.hasOwnProperty(t) && y(`Cannot register multiple overloads of a function with the same number of arguments (${t})!`), u[r].overloadTable[t] = e) : (u[r] = e, t !== void 0 && (u[r].numArguments = t));
    }, Oe = (r, e, t) => {
      switch (e) {
        case 1:
          return t ? function(n) {
            return this.fromWireType(k[n]);
          } : function(n) {
            return this.fromWireType(g[n]);
          };
        case 2:
          return t ? function(n) {
            return this.fromWireType(x[n >> 1]);
          } : function(n) {
            return this.fromWireType(N[n >> 1]);
          };
        case 4:
          return t ? function(n) {
            return this.fromWireType(D[n >> 2]);
          } : function(n) {
            return this.fromWireType(d[n >> 2]);
          };
        default:
          throw new TypeError(`invalid integer width (${e}): ${r}`);
      }
    }, Ve = (r, e, t, n) => {
      e = h(e);
      function a() {
      }
      a.values = {}, E(r, {
        name: e,
        constructor: a,
        fromWireType: function(i) {
          return this.constructor.values[i];
        },
        toWireType: (i, s) => s.value,
        argPackAdvance: R,
        readValueFromPointer: Oe(e, t, n),
        destructorFunction: null
      }), Or(e, a);
    }, tr = (r, e) => Object.defineProperty(e, "name", {
      value: r
    }), Vr = (r) => {
      var e = qr(r), t = h(e);
      return P(e), t;
    }, Hr = (r, e) => {
      var t = M[r];
      return t === void 0 && y(`${e} has unknown type ${Vr(r)}`), t;
    }, He = (r, e, t) => {
      var n = Hr(r, "enum");
      e = h(e);
      var a = n.constructor, i = Object.create(n.constructor.prototype, {
        value: {
          value: t
        },
        constructor: {
          value: tr(`${n.name}_${e}`, function() {
          })
        }
      });
      a.values[t] = i, a[e] = i;
    }, Be = (r, e) => {
      switch (e) {
        case 4:
          return function(t) {
            return this.fromWireType($r[t >> 2]);
          };
        case 8:
          return function(t) {
            return this.fromWireType(Ar[t >> 3]);
          };
        default:
          throw new TypeError(`invalid float width (${e}): ${r}`);
      }
    }, Ne = (r, e, t) => {
      e = h(e), E(r, {
        name: e,
        fromWireType: (n) => n,
        toWireType: (n, a) => a,
        argPackAdvance: R,
        readValueFromPointer: Be(e, t),
        destructorFunction: null
      });
    };
    function Xe(r) {
      for (var e = 1; e < r.length; ++e)
        if (r[e] !== null && r[e].destructorFunction === void 0)
          return !0;
      return !1;
    }
    function Le(r, e, t, n, a, i) {
      var s = e.length;
      s < 2 && y("argTypes array size mismatch! Must at least get return value and 'this' types!");
      var o = e[1] !== null && t !== null, f = Xe(e), c = e[0].name !== "void", v = s - 2, l = new Array(v), _ = [], m = [], U = function() {
        arguments.length !== v && y(`function ${r} called with ${arguments.length} arguments, expected ${v}`), m.length = 0;
        var Z;
        _.length = o ? 2 : 1, _[0] = a, o && (Z = e[1].toWireType(m, this), _[1] = Z);
        for (var C = 0; C < v; ++C)
          l[C] = e[C + 2].toWireType(m, C < 0 || arguments.length <= C ? void 0 : arguments[C]), _.push(l[C]);
        var q = n(..._);
        function gr(ir) {
          if (f)
            vr(m);
          else
            for (var V = o ? 1 : 2; V < e.length; V++) {
              var Gt = V === 1 ? Z : l[V - 2];
              e[V].destructorFunction !== null && e[V].destructorFunction(Gt);
            }
          if (c)
            return e[0].fromWireType(ir);
        }
        return gr(q);
      };
      return tr(r, U);
    }
    var Ze = (r, e) => {
      for (var t = [], n = 0; n < r; n++)
        t.push(d[e + n * 4 >> 2]);
      return t;
    }, qe = (r, e, t) => {
      u.hasOwnProperty(r) || Mr("Replacing nonexistent public symbol"), u[r].overloadTable !== void 0 && t !== void 0 ? u[r].overloadTable[t] = e : (u[r] = e, u[r].argCount = t);
    }, Ge = (r, e, t) => {
      r = r.replace(/p/g, "i");
      var n = u["dynCall_" + r];
      return n(e, ...t);
    }, nr = [], Br, b = (r) => {
      var e = nr[r];
      return e || (r >= nr.length && (nr.length = r + 1), nr[r] = e = Br.get(r)), e;
    }, Ke = function(r, e) {
      let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
      if (r.includes("j"))
        return Ge(r, e, t);
      var n = b(e)(...t);
      return n;
    }, Je = (r, e) => function() {
      for (var t = arguments.length, n = new Array(t), a = 0; a < t; a++)
        n[a] = arguments[a];
      return Ke(r, e, n);
    }, L = (r, e) => {
      r = h(r);
      function t() {
        return r.includes("j") ? Je(r, e) : b(e);
      }
      var n = t();
      return typeof n != "function" && y(`unknown function pointer with signature ${r}: ${e}`), n;
    }, Qe = (r, e) => {
      var t = tr(e, function(n) {
        this.name = e, this.message = n;
        var a = new Error(n).stack;
        a !== void 0 && (this.stack = this.toString() + `
` + a.replace(/^Error(:[^\n]*)?\n/, ""));
      });
      return t.prototype = Object.create(r.prototype), t.prototype.constructor = t, t.prototype.toString = function() {
        return this.message === void 0 ? this.name : `${this.name}: ${this.message}`;
      }, t;
    }, Nr, Ye = (r, e) => {
      var t = [], n = {};
      function a(i) {
        if (!n[i] && !M[i]) {
          if (er[i]) {
            er[i].forEach(a);
            return;
          }
          t.push(i), n[i] = !0;
        }
      }
      throw e.forEach(a), new Nr(`${r}: ` + t.map(Vr).join([", "]));
    }, ze = (r) => {
      r = r.trim();
      const e = r.indexOf("(");
      return e !== -1 ? r.substr(0, e) : r;
    }, rt = (r, e, t, n, a, i, s) => {
      var o = Ze(e, t);
      r = h(r), r = ze(r), a = L(n, a), Or(r, function() {
        Ye(`Cannot call ${r} due to unbound types`, o);
      }, e - 1), Ir([], o, (f) => {
        var c = [f[0], null].concat(f.slice(1));
        return qe(r, Le(r, c, null, a, i), e - 1), [];
      });
    }, et = (r, e, t) => {
      switch (e) {
        case 1:
          return t ? (n) => k[n] : (n) => g[n];
        case 2:
          return t ? (n) => x[n >> 1] : (n) => N[n >> 1];
        case 4:
          return t ? (n) => D[n >> 2] : (n) => d[n >> 2];
        default:
          throw new TypeError(`invalid integer width (${e}): ${r}`);
      }
    }, tt = (r, e, t, n, a) => {
      e = h(e);
      var i = (v) => v;
      if (n === 0) {
        var s = 32 - 8 * t;
        i = (v) => v << s >>> s;
      }
      var o = e.includes("unsigned"), f = (v, l) => {
      }, c;
      o ? c = function(v, l) {
        return f(l, this.name), l >>> 0;
      } : c = function(v, l) {
        return f(l, this.name), l;
      }, E(r, {
        name: e,
        fromWireType: i,
        toWireType: c,
        argPackAdvance: R,
        readValueFromPointer: et(e, t, n !== 0),
        destructorFunction: null
      });
    }, nt = (r, e, t) => {
      var n = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], a = n[e];
      function i(s) {
        var o = d[s >> 2], f = d[s + 4 >> 2];
        return new a(k.buffer, f, o);
      }
      t = h(t), E(r, {
        name: t,
        fromWireType: i,
        argPackAdvance: R,
        readValueFromPointer: i
      }, {
        ignoreDuplicateRegistrations: !0
      });
    }, at = (r, e, t, n) => {
      if (!(n > 0)) return 0;
      for (var a = t, i = t + n - 1, s = 0; s < r.length; ++s) {
        var o = r.charCodeAt(s);
        if (o >= 55296 && o <= 57343) {
          var f = r.charCodeAt(++s);
          o = 65536 + ((o & 1023) << 10) | f & 1023;
        }
        if (o <= 127) {
          if (t >= i) break;
          e[t++] = o;
        } else if (o <= 2047) {
          if (t + 1 >= i) break;
          e[t++] = 192 | o >> 6, e[t++] = 128 | o & 63;
        } else if (o <= 65535) {
          if (t + 2 >= i) break;
          e[t++] = 224 | o >> 12, e[t++] = 128 | o >> 6 & 63, e[t++] = 128 | o & 63;
        } else {
          if (t + 3 >= i) break;
          e[t++] = 240 | o >> 18, e[t++] = 128 | o >> 12 & 63, e[t++] = 128 | o >> 6 & 63, e[t++] = 128 | o & 63;
        }
      }
      return e[t] = 0, t - a;
    }, it = (r, e, t) => at(r, g, e, t), ot = (r) => {
      for (var e = 0, t = 0; t < r.length; ++t) {
        var n = r.charCodeAt(t);
        n <= 127 ? e++ : n <= 2047 ? e += 2 : n >= 55296 && n <= 57343 ? (e += 4, ++t) : e += 3;
      }
      return e;
    }, Xr = typeof TextDecoder < "u" ? new TextDecoder() : void 0, st = (r, e, t) => {
      for (var n = e + t, a = e; r[a] && !(a >= n); ) ++a;
      if (a - e > 16 && r.buffer && Xr)
        return Xr.decode(r.subarray(e, a));
      for (var i = ""; e < a; ) {
        var s = r[e++];
        if (!(s & 128)) {
          i += String.fromCharCode(s);
          continue;
        }
        var o = r[e++] & 63;
        if ((s & 224) == 192) {
          i += String.fromCharCode((s & 31) << 6 | o);
          continue;
        }
        var f = r[e++] & 63;
        if ((s & 240) == 224 ? s = (s & 15) << 12 | o << 6 | f : s = (s & 7) << 18 | o << 12 | f << 6 | r[e++] & 63, s < 65536)
          i += String.fromCharCode(s);
        else {
          var c = s - 65536;
          i += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);
        }
      }
      return i;
    }, ut = (r, e) => r ? st(g, r, e) : "", ft = (r, e) => {
      e = h(e);
      var t = e === "std::string";
      E(r, {
        name: e,
        fromWireType(n) {
          var a = d[n >> 2], i = n + 4, s;
          if (t)
            for (var o = i, f = 0; f <= a; ++f) {
              var c = i + f;
              if (f == a || g[c] == 0) {
                var v = c - o, l = ut(o, v);
                s === void 0 ? s = l : (s += "\0", s += l), o = c + 1;
              }
            }
          else {
            for (var _ = new Array(a), f = 0; f < a; ++f)
              _[f] = String.fromCharCode(g[i + f]);
            s = _.join("");
          }
          return P(n), s;
        },
        toWireType(n, a) {
          a instanceof ArrayBuffer && (a = new Uint8Array(a));
          var i, s = typeof a == "string";
          s || a instanceof Uint8Array || a instanceof Uint8ClampedArray || a instanceof Int8Array || y("Cannot pass non-string to std::string"), t && s ? i = ot(a) : i = a.length;
          var o = pr(4 + i + 1), f = o + 4;
          if (d[o >> 2] = i, t && s)
            it(a, f, i + 1);
          else if (s)
            for (var c = 0; c < i; ++c) {
              var v = a.charCodeAt(c);
              v > 255 && (P(f), y("String has UTF-16 code units that do not fit in 8 bits")), g[f + c] = v;
            }
          else
            for (var c = 0; c < i; ++c)
              g[f + c] = a[c];
          return n !== null && n.push(P, o), o;
        },
        argPackAdvance: R,
        readValueFromPointer: rr,
        destructorFunction(n) {
          P(n);
        }
      });
    }, Lr = typeof TextDecoder < "u" ? new TextDecoder("utf-16le") : void 0, ct = (r, e) => {
      for (var t = r, n = t >> 1, a = n + e / 2; !(n >= a) && N[n]; ) ++n;
      if (t = n << 1, t - r > 32 && Lr) return Lr.decode(g.subarray(r, t));
      for (var i = "", s = 0; !(s >= e / 2); ++s) {
        var o = x[r + s * 2 >> 1];
        if (o == 0) break;
        i += String.fromCharCode(o);
      }
      return i;
    }, vt = (r, e, t) => {
      var n;
      if ((n = t) !== null && n !== void 0 || (t = 2147483647), t < 2) return 0;
      t -= 2;
      for (var a = e, i = t < r.length * 2 ? t / 2 : r.length, s = 0; s < i; ++s) {
        var o = r.charCodeAt(s);
        x[e >> 1] = o, e += 2;
      }
      return x[e >> 1] = 0, e - a;
    }, lt = (r) => r.length * 2, dt = (r, e) => {
      for (var t = 0, n = ""; !(t >= e / 4); ) {
        var a = D[r + t * 4 >> 2];
        if (a == 0) break;
        if (++t, a >= 65536) {
          var i = a - 65536;
          n += String.fromCharCode(55296 | i >> 10, 56320 | i & 1023);
        } else
          n += String.fromCharCode(a);
      }
      return n;
    }, _t = (r, e, t) => {
      var n;
      if ((n = t) !== null && n !== void 0 || (t = 2147483647), t < 4) return 0;
      for (var a = e, i = a + t - 4, s = 0; s < r.length; ++s) {
        var o = r.charCodeAt(s);
        if (o >= 55296 && o <= 57343) {
          var f = r.charCodeAt(++s);
          o = 65536 + ((o & 1023) << 10) | f & 1023;
        }
        if (D[e >> 2] = o, e += 4, e + 4 > i) break;
      }
      return D[e >> 2] = 0, e - a;
    }, pt = (r) => {
      for (var e = 0, t = 0; t < r.length; ++t) {
        var n = r.charCodeAt(t);
        n >= 55296 && n <= 57343 && ++t, e += 4;
      }
      return e;
    }, gt = (r, e, t) => {
      t = h(t);
      var n, a, i, s;
      e === 2 ? (n = ct, a = vt, s = lt, i = (o) => N[o >> 1]) : e === 4 && (n = dt, a = _t, s = pt, i = (o) => d[o >> 2]), E(r, {
        name: t,
        fromWireType: (o) => {
          for (var f = d[o >> 2], c, v = o + 4, l = 0; l <= f; ++l) {
            var _ = o + 4 + l * e;
            if (l == f || i(_) == 0) {
              var m = _ - v, U = n(v, m);
              c === void 0 ? c = U : (c += "\0", c += U), v = _ + e;
            }
          }
          return P(o), c;
        },
        toWireType: (o, f) => {
          typeof f != "string" && y(`Cannot pass non-string to C++ string type ${t}`);
          var c = s(f), v = pr(4 + c + e);
          return d[v >> 2] = c / e, a(f, v + 4, c + e), o !== null && o.push(P, v), v;
        },
        argPackAdvance: R,
        readValueFromPointer: rr,
        destructorFunction(o) {
          P(o);
        }
      });
    }, ht = (r, e, t, n, a, i) => {
      z[r] = {
        name: h(e),
        rawConstructor: L(t, n),
        rawDestructor: L(a, i),
        fields: []
      };
    }, mt = (r, e, t, n, a, i, s, o, f, c) => {
      z[r].fields.push({
        fieldName: h(e),
        getterReturnType: t,
        getter: L(n, a),
        getterContext: i,
        setterArgumentType: s,
        setter: L(o, f),
        setterContext: c
      });
    }, yt = (r, e) => {
      e = h(e), E(r, {
        isVoid: !0,
        name: e,
        argPackAdvance: 0,
        fromWireType: () => {
        },
        toWireType: (t, n) => {
        }
      });
    }, bt = (r, e, t) => g.copyWithin(r, e, e + t), _r = [], wt = (r, e, t, n) => (r = _r[r], e = I.toValue(e), r(null, e, t, n)), Tt = {}, $t = (r) => {
      var e = Tt[r];
      return e === void 0 ? h(r) : e;
    }, Zr = () => {
      if (typeof globalThis == "object")
        return globalThis;
      function r(e) {
        e.$$$embind_global$$$ = e;
        var t = typeof $$$embind_global$$$ == "object" && e.$$$embind_global$$$ == e;
        return t || delete e.$$$embind_global$$$, t;
      }
      if (typeof $$$embind_global$$$ == "object" || (typeof global == "object" && r(global) ? $$$embind_global$$$ = global : typeof self == "object" && r(self) && ($$$embind_global$$$ = self), typeof $$$embind_global$$$ == "object"))
        return $$$embind_global$$$;
      throw Error("unable to get global object.");
    }, At = (r) => r === 0 ? I.toHandle(Zr()) : (r = $t(r), I.toHandle(Zr()[r])), Et = (r) => {
      var e = _r.length;
      return _r.push(r), e;
    }, Ct = (r, e) => {
      for (var t = new Array(r), n = 0; n < r; ++n)
        t[n] = Hr(d[e + n * 4 >> 2], "parameter " + n);
      return t;
    }, Rt = Reflect.construct, Ft = (r, e, t) => {
      var n = [], a = r.toWireType(n, t);
      return n.length && (d[e >> 2] = I.toHandle(n)), a;
    }, Pt = (r, e, t) => {
      var n = Ct(r, e), a = n.shift();
      r--;
      var i = new Array(r), s = (f, c, v, l) => {
        for (var _ = 0, m = 0; m < r; ++m)
          i[m] = n[m].readValueFromPointer(l + _), _ += n[m].argPackAdvance;
        var U = t === 1 ? Rt(c, i) : c.apply(f, i);
        return Ft(a, v, U);
      }, o = `methodCaller<(${n.map((f) => f.name).join(", ")}) => ${a.name}>`;
      return Et(tr(o, s));
    }, Wt = (r) => {
      r > 9 && (F[r + 1] += 1);
    }, kt = (r) => {
      var e = I.toValue(r);
      vr(e), dr(r);
    }, Ut = () => 2147483648, St = (r) => {
      var e = J.buffer, t = (r - e.byteLength + 65535) / 65536;
      try {
        return J.grow(t), Er(), 1;
      } catch {
      }
    }, jt = (r) => {
      var e = g.length;
      r >>>= 0;
      var t = Ut();
      if (r > t)
        return !1;
      for (var n = (f, c) => f + (c - f % c) % c, a = 1; a <= 4; a *= 2) {
        var i = e * (1 + 0.2 / a);
        i = Math.min(i, r + 100663296);
        var s = Math.min(t, n(Math.max(r, i), 65536)), o = St(s);
        if (o)
          return !0;
      }
      return !1;
    }, Mt = (r) => r;
    jr = u.InternalError = class extends Error {
      constructor(e) {
        super(e), this.name = "InternalError";
      }
    }, ke(), Dr = u.BindingError = class extends Error {
      constructor(e) {
        super(e), this.name = "BindingError";
      }
    }, Me(), Nr = u.UnboundTypeError = Qe(Error, "UnboundTypeError");
    var It = {
      q: we,
      p: Te,
      g: Ae,
      c: Ee,
      k: Ce,
      a: Re,
      i: $e,
      C: Fe,
      M: Pe,
      B: We,
      H: Se,
      G: xe,
      K: Ve,
      b: He,
      u: Ne,
      L: rt,
      h: tt,
      e: nt,
      t: ft,
      r: gt,
      v: ht,
      N: mt,
      I: yt,
      F: bt,
      y: wt,
      P: dr,
      A: At,
      z: Pt,
      w: Wt,
      Q: kt,
      E: jt,
      x: Bt,
      d: xt,
      m: Nt,
      n: Ht,
      o: Xt,
      f: Dt,
      s: qt,
      l: Zt,
      D: Vt,
      J: Ot,
      j: Lt,
      O: Mt
    }, p = be(), qr = (r) => (qr = p.T)(r), pr = u._malloc = (r) => (pr = u._malloc = p.V)(r), P = u._free = (r) => (P = u._free = p.W)(r), w = (r, e) => (w = p.X)(r, e), Gr = (r) => (Gr = p.Y)(r), Kr = (r) => (Kr = p.Z)(r), Jr = () => (Jr = p._)(), Qr = (r) => (Qr = p.$)(r), Yr = (r) => (Yr = p.aa)(r), zr = (r, e, t) => (zr = p.ba)(r, e, t), re = (r) => (re = p.ca)(r);
    function xt(r, e) {
      var t = $();
      try {
        return b(r)(e);
      } catch (n) {
        if (T(t), n !== n + 0) throw n;
        w(1, 0);
      }
    }
    function Dt(r, e) {
      var t = $();
      try {
        b(r)(e);
      } catch (n) {
        if (T(t), n !== n + 0) throw n;
        w(1, 0);
      }
    }
    function Ot(r, e, t, n, a, i) {
      var s = $();
      try {
        b(r)(e, t, n, a, i);
      } catch (o) {
        if (T(s), o !== o + 0) throw o;
        w(1, 0);
      }
    }
    function Vt(r, e, t, n, a) {
      var i = $();
      try {
        b(r)(e, t, n, a);
      } catch (s) {
        if (T(i), s !== s + 0) throw s;
        w(1, 0);
      }
    }
    function Ht(r, e, t, n) {
      var a = $();
      try {
        return b(r)(e, t, n);
      } catch (i) {
        if (T(a), i !== i + 0) throw i;
        w(1, 0);
      }
    }
    function Bt(r, e, t, n, a) {
      var i = $();
      try {
        return b(r)(e, t, n, a);
      } catch (s) {
        if (T(i), s !== s + 0) throw s;
        w(1, 0);
      }
    }
    function Nt(r, e, t) {
      var n = $();
      try {
        return b(r)(e, t);
      } catch (a) {
        if (T(n), a !== a + 0) throw a;
        w(1, 0);
      }
    }
    function Xt(r) {
      var e = $();
      try {
        b(r)();
      } catch (t) {
        if (T(e), t !== t + 0) throw t;
        w(1, 0);
      }
    }
    function Lt(r, e, t, n, a, i, s, o, f, c, v) {
      var l = $();
      try {
        b(r)(e, t, n, a, i, s, o, f, c, v);
      } catch (_) {
        if (T(l), _ !== _ + 0) throw _;
        w(1, 0);
      }
    }
    function Zt(r, e, t, n) {
      var a = $();
      try {
        b(r)(e, t, n);
      } catch (i) {
        if (T(a), i !== i + 0) throw i;
        w(1, 0);
      }
    }
    function qt(r, e, t) {
      var n = $();
      try {
        b(r)(e, t);
      } catch (a) {
        if (T(n), a !== a + 0) throw a;
        w(1, 0);
      }
    }
    var ar;
    X = function r() {
      ar || ee(), ar || (X = r);
    };
    function ee() {
      if (S > 0 || (se(), S > 0))
        return;
      function r() {
        var e;
        ar || (ar = !0, u.calledRun = !0, !Tr && (ue(), yr(u), (e = u.onRuntimeInitialized) === null || e === void 0 || e.call(u), fe()));
      }
      u.setStatus ? (u.setStatus("Running..."), setTimeout(function() {
        setTimeout(function() {
          u.setStatus("");
        }, 1), r();
      }, 1)) : r();
    }
    if (u.preInit)
      for (typeof u.preInit == "function" && (u.preInit = [u.preInit]); u.preInit.length > 0; )
        u.preInit.pop()();
    return ee(), mr = ne, mr;
  };
})();
function en(W) {
  return Kt(
    hr,
    W
  );
}
function tn(W) {
  return Jt(
    hr,
    W
  );
}
async function nn(W, G) {
  return Qt(
    hr,
    W,
    G
  );
}
export {
  sn as barcodeFormats,
  un as characterSets,
  fn as defaultEncodeHints,
  cn as defaultWriterOptions,
  en as getZXingModule,
  vn as purgeZXingModule,
  tn as setZXingModuleOverrides,
  nn as writeBarcodeToImageFile,
  ln as writeInputEccLevels
};
